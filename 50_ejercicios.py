# -*- coding: utf-8 -*-
"""50 ejercicios.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CnV_luEm-zbGSamuH8MI5rBZ_azIc28R
"""

# ============================================================
# Ejercicio 1: Balanceo de paréntesis
# Enunciado: Verificar si una expresión con paréntesis, corchetes y llaves
# está correctamente balanceada usando una pila.
# ============================================================

def balanceo_parentesis(expresion):  # Definimos la función con parámetro 'expresion'
    pila = []  # Usaremos una lista como pila para almacenar símbolos
    parejas = {')': '(', ']': '[', '}': '{'}  # Diccionario con los pares de apertura/cierre
    for c in expresion:  # Recorremos cada carácter de la expresión
        if c in '([{':  # Si es símbolo de apertura
            pila.append(c)  # Lo añadimos a la pila
        elif c in ')]}':  # Si es símbolo de cierre
            if not pila or pila[-1] != parejas[c]:  # Si la pila está vacía o no coincide con el último abierto
                return False  # La expresión está mal balanceada
            pila.pop()  # Eliminamos el símbolo de apertura correspondiente
    return len(pila) == 0  # Si la pila queda vacía, está bien balanceada

print(balanceo_parentesis("({[]})"))  # Devuelve True
print(balanceo_parentesis("({[})"))   # Devuelve False

# ============================================================
# Ejercicio 2: Conversión de infijo a postfijo
# Enunciado: Convertir expresión matemática en notación infija a postfija usando pila.
# ============================================================

def infijo_a_postfijo(expresion):  # Función que recibe la expresión en formato string
    precedencia = {'+':1,'-':1,'*':2,'/':2,'^':3}  # Diccionario con precedencia de operadores
    pila = []  # Pila de operadores
    salida = []  # Lista de salida
    for token in expresion.split():  # Iteramos por cada token (separados por espacio)
        if token.isalnum():  # Si es operando (número/letra)
            salida.append(token)  # Lo añadimos directo a la salida
        elif token == '(':  # Si es paréntesis de apertura
            pila.append(token)  # Lo metemos en la pila
        elif token == ')':  # Si es paréntesis de cierre
            while pila and pila[-1] != '(':  # Mientras no encontremos '('
                salida.append(pila.pop())  # Pasamos operadores a la salida
            pila.pop()  # Quitamos el '('
        else:  # Si es operador
            while pila and pila[-1] != '(' and precedencia.get(token,0) <= precedencia.get(pila[-1],0):
                salida.append(pila.pop())  # Sacamos operadores de mayor/igual precedencia
            pila.append(token)  # Ponemos el actual en la pila
    while pila:  # Vaciamos pila al final
        salida.append(pila.pop())
    return ' '.join(salida)  # Retornamos como string separado por espacios

print(infijo_a_postfijo("( A + B ) * C"))  # Devuelve "A B + C *"

# ============================================================
# Ejercicio 3: Evaluar expresión postfija
# Enunciado: Evaluar una expresión aritmética en notación postfija usando pila.
# ============================================================

def evaluar_postfijo(expresion):  # Función que recibe expresión postfija
    pila = []  # Pila de operandos
    for token in expresion.split():  # Recorremos cada elemento
        if token.replace('.','',1).isdigit():  # Si es número (entero o decimal)
            pila.append(float(token) if '.' in token else int(token))  # Convertimos y agregamos
        else:  # Si es operador
            b = pila.pop()  # Extraemos segundo operando
            a = pila.pop()  # Extraemos primer operando
            if token=='+': pila.append(a+b)  # Suma
            elif token=='-': pila.append(a-b)  # Resta
            elif token=='*': pila.append(a*b)  # Multiplicación
            elif token=='/': pila.append(a/b)  # División
    return pila[0]  # Al final, queda el resultado en la pila

print(evaluar_postfijo("3 4 + 2 *"))  # Devuelve 14

# ============================================================
# Ejercicio 4: Invertir lista con pila
# Enunciado: Usar una pila para invertir el orden de una lista.
# ============================================================

def invertir_lista_pila(lista):  # Función que recibe lista
    pila = []  # Pila temporal
    for e in lista: pila.append(e)  # Apilamos todos los elementos
    lista_inv = []  # Lista resultado
    while pila: lista_inv.append(pila.pop())  # Desapilamos para invertir orden
    return lista_inv

print(invertir_lista_pila([1,2,3,4,5]))  # Devuelve [5,4,3,2,1]

# ============================================================
# Ejercicio 5: Eliminar duplicados consecutivos
# Enunciado: Dada una lista, eliminar duplicados consecutivos.
# ============================================================

def eliminar_consecutivos_duplicados(lista):  # Función que recibe lista
    pila = []  # Pila resultado
    for e in lista:  # Iteramos elementos
        if not pila or pila[-1] != e:  # Si la pila está vacía o el último no es igual
            pila.append(e)  # Lo agregamos
    return pila  # Retornamos lista sin duplicados consecutivos

print(eliminar_consecutivos_duplicados([1,2,2,3,4,4,4,5]))  # Devuelve [1,2,3,4,5]

# ============================================================
# Ejercicio 6: Siguiente elemento mayor
# Enunciado: Para cada elemento, encontrar el siguiente mayor a su derecha.
# ============================================================

def siguiente_elemento_mayor(lista):
    pila = []  # Guardaremos índices pendientes
    resultado = [-1]*len(lista)  # Inicializamos con -1
    for i, val in enumerate(lista):  # Recorremos lista con índice
        while pila and lista[pila[-1]] < val:  # Mientras haya un menor pendiente
            idx = pila.pop()  # Sacamos índice
            resultado[idx] = val  # Ese valor es el siguiente mayor
        pila.append(i)  # Guardamos el índice actual en pila
    return resultado

print(siguiente_elemento_mayor([4,5,2,10]))  # Devuelve [5,10,10,-1]

# ============================================================
# Ejercicio 7: Validar secuencia push/pop
# Enunciado: Comprobar si una secuencia de pops es posible con una pila.
# ============================================================

def validar_secuencia_push_pop(push_seq, pop_seq):
    pila = []  # Pila simulada
    i = 0  # Índice para pop_seq
    for num in push_seq:  # Recorremos secuencia de pushes
        pila.append(num)  # Apilamos
        while pila and i < len(pop_seq) and pila[-1] == pop_seq[i]:
            pila.pop()  # Coincide con esperado, desapilamos
            i += 1  # Avanzamos en pop_seq
    return i == len(pop_seq)  # Si completamos todos los pops, es válida

print(validar_secuencia_push_pop([1,2,3,4,5],[4,5,3,2,1]))  # True

# ============================================================
# Ejercicio 8: Pila con mínimo O(1)
# Enunciado: Implementar pila que devuelva el mínimo actual en O(1).
# ============================================================

class PilaConMinimo:
    def __init__(self):
        self.p = []  # Pila normal
        self.min_p = []  # Pila auxiliar para mínimos
    def push(self,v):
        self.p.append(v)  # Apilamos valor
        if not self.min_p or v <= self.min_p[-1]:  # Si es nuevo mínimo
            self.min_p.append(v)  # Lo guardamos en min_p
    def pop(self):
        if not self.p: return None  # Si está vacía
        v = self.p.pop()  # Sacamos tope
        if v == self.min_p[-1]: self.min_p.pop()  # Si era el mínimo, lo quitamos de min_p
        return v
    def get_min(self):
        return self.min_p[-1] if self.min_p else None  # Retornamos mínimo actual

p = PilaConMinimo()
p.push(3); p.push(1); p.push(2)
print(p.get_min())  # Devuelve 1

# ============================================================
# Ejercicio 9: Dos pilas en un arreglo
# Enunciado: Implementar dos pilas en un mismo arreglo fijo.
# ============================================================

class DosPilas:
    def __init__(self,cap):
        self.cap=cap  # Capacidad total
        self.arr=[None]*cap  # Arreglo base
        self.top1=-1  # Tope pila1
        self.top2=cap  # Tope pila2
    def push1(self,v):
        if self.top1 < self.top2 -1:  # Si hay espacio
            self.top1 +=1
            self.arr[self.top1]=v
    def push2(self,v):
        if self.top1 < self.top2 -1:
            self.top2 -=1
            self.arr[self.top2]=v
    def pop1(self):
        if self.top1>=0:
            v=self.arr[self.top1]
            self.top1-=1
            return v
    def pop2(self):
        if self.top2 < self.cap:
            v=self.arr[self.top2]
            self.top2+=1
            return v

dp = DosPilas(5)
dp.push1(1); dp.push2(2)
print(dp.pop1())  # Devuelve 1

# ============================================================
# Ejercicio 10: Ordenar pila
# Enunciado: Ordenar una pila utilizando otra pila auxiliar.
# ============================================================

def ordenar_pila(pila):
    pila_temp = []  # Pila auxiliar
    while pila:  # Mientras la pila original tenga elementos
        temp = pila.pop()  # Sacamos tope
        while pila_temp and pila_temp[-1] > temp:  # Mientras el aux sea mayor
            pila.append(pila_temp.pop())  # Regresamos a la pila original
        pila_temp.append(temp)  # Insertamos en la posición correcta
    return pila_temp

print(ordenar_pila([3,1,4,2]))  # Devuelve [1,2,3,4]

# ============================================================
# Ejercicio 11: Cola con pilas
# Enunciado: Implementar una cola usando dos pilas.
# ============================================================

class ColaConPilas:
    def __init__(self):
        self.entrada=[]  # Pila para encolar
        self.salida=[]   # Pila para desencolar
    def enqueue(self,v):
        self.entrada.append(v)  # Agregamos a la pila de entrada
    def dequeue(self):
        if not self.salida:  # Si la pila de salida está vacía
            while self.entrada:  # Pasamos todos los elementos
                self.salida.append(self.entrada.pop())
        return self.salida.pop() if self.salida else None  # Devolvemos el último

c=ColaConPilas()
c.enqueue(1); c.enqueue(2)
print(c.dequeue())  # Devuelve 1

# ============================================================
# Ejercicio 12: Cola circular
# Enunciado: Implementar una cola circular en un arreglo de tamaño fijo.
# ============================================================

class ColaCircular:
    def __init__(self,cap):
        self.cap=cap  # Capacidad fija
        self.arr=[None]*cap  # Arreglo
        self.frente=0  # Índice frente
        self.final=-1  # Índice final
        self.size=0    # Tamaño actual
    def enqueue(self,v):
        if self.size==self.cap: return False  # Si está llena
        self.final=(self.final+1)%self.cap  # Avanzamos circular
        self.arr[self.final]=v  # Insertamos
        self.size+=1
        return True
    def dequeue(self):
        if self.size==0: return None  # Vacía
        v=self.arr[self.frente]  # Guardamos valor
        self.frente=(self.frente+1)%self.cap  # Avanzamos circular
        self.size-=1
        return v

q=ColaCircular(3)
q.enqueue(1); q.enqueue(2)
print(q.dequeue())  # Devuelve 1

# ============================================================
# Ejercicio 13: Revertir los primeros k elementos de una cola
# ============================================================

def revertir_primeros_k(cola,k):
    pila=[]  # Pila auxiliar
    for _ in range(k):  # Tomamos k elementos
        e=cola.dequeue()
        if e is None: break
        pila.append(e)
    while pila: cola.enqueue(pila.pop())  # Volvemos a encolar invertidos
    return cola

cola=ColaConPilas()
[cola.enqueue(i) for i in range(1,6)]
revertir_primeros_k(cola,3)
res=[]
while True:
    x=cola.dequeue()
    if x is None: break
    res.append(x)
print(res)  # Devuelve [4,5,3,2,1]

# ============================================================
# Ejercicio 14: Generar números binarios con cola
# ============================================================

def generar_numeros_binarios(n):
    if n<=0: return []
    res=[]
    cola=["1"]  # Cola inicial con "1"
    for _ in range(n):  # Generamos n números
        actual=cola.pop(0)  # Sacamos el primero
        res.append(actual)  # Lo añadimos a la lista
        cola.append(actual+"0")  # Encolamos con "0"
        cola.append(actual+"1")  # Encolamos con "1"
    return res

print(generar_numeros_binarios(5))  # ['1','10','11','100','101']

# ============================================================
# Ejercicio 15: Cola de prioridad simple
# ============================================================

class ColaPrioridad:
    def __init__(self):
        self.elems=[]  # Lista de elementos (valor, prioridad)
    def enqueue(self,val,prio):
        self.elems.append((val,prio))  # Insertamos par
        self.elems.sort(key=lambda x:x[1])  # Ordenamos por prioridad
    def dequeue(self):
        return self.elems.pop(0)[0] if self.elems else None  # Sacamos el de menor prioridad

cp=ColaPrioridad()
cp.enqueue("tarea1",2); cp.enqueue("tarea2",1)
print(cp.dequeue())  # Devuelve "tarea2"

# ============================================================
# Ejercicio 16: Cola eficiente con dos pilas
# ============================================================

class ColaEficiente:
    def __init__(self):
        self.s_in=[]   # Pila de entrada
        self.s_out=[]  # Pila de salida
    def enqueue(self,v):
        self.s_in.append(v)  # Encolamos en s_in
    def _transferir(self):
        while self.s_in:  # Movemos todos de entrada a salida
            self.s_out.append(self.s_in.pop())
    def dequeue(self):
        if not self.s_out: self._transferir()  # Si s_out está vacía, transferimos
        return self.s_out.pop() if self.s_out else None

c=ColaEficiente()
c.enqueue(1); c.enqueue(2)
print(c.dequeue())  # Devuelve 1

# ============================================================
# Ejercicio 17: Intercalar dos colas
# ============================================================

def intercalar_colas(c1,c2):
    res=[]
    while c1 and c2:  # Mientras ambas tengan elementos
        res.append(c1.pop(0))  # Tomamos de la primera
        res.append(c2.pop(0))  # Luego de la segunda
    res.extend(c1)  # Agregamos sobrantes de c1
    res.extend(c2)  # Agregamos sobrantes de c2
    return res

print(intercalar_colas([1,3,5],[2,4,6,8]))  # Devuelve [1,2,3,4,5,6,8]

# ============================================================
# Ejercicio 18: Revertir cola recursivamente
# ============================================================

def revertir_cola_recursiva(cola):
    if not cola: return  # Caso base: cola vacía
    frente = cola.pop(0)  # Quitamos el primero
    revertir_cola_recursiva(cola)  # Llamada recursiva
    cola.append(frente)  # Lo ponemos al final

cola=[1,2,3,4,5]
revertir_cola_recursiva(cola)
print(cola)  # Devuelve [5,4,3,2,1]

# ============================================================
# Ejercicio 19: Problema del puente
# Enunciado: Simulación de un puente con capacidad limitada.
# ============================================================

class Puente:
    def __init__(self,cap):
        self.cap=cap  # Capacidad
        self.en_puente=[]  # Vehículos en el puente
        self.cola=[]  # Vehículos esperando
    def llegar(self,veh):
        if len(self.en_puente) < self.cap:
            self.en_puente.append(veh)  # Entra al puente
        else:
            self.cola.append(veh)  # Se queda esperando
    def salir(self):
        if self.en_puente:
            v=self.en_puente.pop(0)  # Sale el primero
            if self.cola:  # Si hay espera
                self.en_puente.append(self.cola.pop(0))  # Entra uno nuevo
            return v

p=Puente(2)
p.llegar("Auto1"); p.llegar("Auto2"); p.llegar("Auto3")
print(p.salir())  # Devuelve "Auto1"

# ============================================================
# Ejercicio 20: Cola con máximo en O(1)
# ============================================================

from collections import deque

class ColaConMaximo:
    def __init__(self):
        self.cola = deque()      # Cola normal
        self.max_deque = deque() # Cola doble para máximos
    def enqueue(self,v):
        self.cola.append(v)  # Encolamos
        while self.max_deque and self.max_deque[-1] < v:
            self.max_deque.pop()  # Eliminamos los menores
        self.max_deque.append(v)  # Añadimos valor
    def dequeue(self):
        if not self.cola: return None
        v = self.cola.popleft()
        if v == self.max_deque[0]:
            self.max_deque.popleft()  # Si era el máximo, lo quitamos
        return v
    def get_max(self):
        return self.max_deque[0] if self.max_deque else None

c = ColaConMaximo()
c.enqueue(3); c.enqueue(1); c.enqueue(2)
print(c.get_max())  # Devuelve 3

# ============================================================
# Ejercicio 21: Intersección de listas ordenadas
# Enunciado: Encontrar elementos comunes entre dos listas ordenadas.
# ============================================================

def interseccion_listas_ordenadas(a,b):
    i=j=0  # Dos índices para recorrer ambas listas
    res=[]  # Lista resultado
    while i<len(a) and j<len(b):  # Mientras haya elementos en ambas
        if a[i]==b[j]:  # Si son iguales
            res.append(a[i])  # Agregamos a resultado
            i+=1; j+=1  # Avanzamos en ambas
        elif a[i] < b[j]:  # Si el de 'a' es menor
            i+=1  # Avanzamos en 'a'
        else:  # Si el de 'b' es menor
            j+=1  # Avanzamos en 'b'
    return res

print(interseccion_listas_ordenadas([1,2,3,4],[2,4,6]))  # [2,4]

# ============================================================
# Ejercicio 22: Unión de listas ordenadas
# Enunciado: Combinar dos listas ordenadas sin duplicados.
# ============================================================

def union_listas_ordenadas(a,b):
    i=j=0
    res=[]
    while i<len(a) and j<len(b):
        if a[i] < b[j]:
            if not res or res[-1] != a[i]: res.append(a[i])
            i+=1
        elif a[i] > b[j]:
            if not res or res[-1] != b[j]: res.append(b[j])
            j+=1
        else:
            if not res or res[-1] != a[i]: res.append(a[i])
            i+=1; j+=1
    for x in a[i:]:
        if not res or res[-1] != x: res.append(x)
    for x in b[j:]:
        if not res or res[-1] != x: res.append(x)
    return res

print(union_listas_ordenadas([1,2,3],[2,3,4]))  # [1,2,3,4]

# ============================================================
# Ejercicio 23: Rotar lista k posiciones a la derecha
# Enunciado: Rotar todos los elementos de una lista k pasos a la derecha.
# ============================================================

def rotar_lista(lista,k):
    if not lista: return lista  # Si está vacía, devolvemos igual
    k = k % len(lista)  # Ajustamos k
    return lista[-k:] + lista[:-k]  # Cortamos y unimos

print(rotar_lista([1,2,3,4,5],2))  # [4,5,1,2,3]

# ============================================================
# Ejercicio 24: Mover ceros al final
# Enunciado: Reordenar lista moviendo los ceros al final, manteniendo orden.
# ============================================================

def mover_ceros_al_final_inplace(lista):
    pos = 0  # Posición para colocar elementos no cero
    for i in range(len(lista)):
        if lista[i] != 0:  # Si no es cero
            lista[pos], lista[i] = lista[i], lista[pos]  # Intercambiamos
            pos += 1

lst=[0,1,0,3,12]
mover_ceros_al_final_inplace(lst)
print(lst)  # [1,3,12,0,0]

# ============================================================
# Ejercicio 25: Encontrar duplicados en lista
# Enunciado: Identificar los números que aparecen más de una vez.
# ============================================================

def encontrar_duplicados(lista):
    vistos=set()  # Elementos ya vistos
    dup=set()     # Duplicados
    for x in lista:
        if x in vistos: dup.add(x)
        else: vistos.add(x)
    return list(dup)

print(encontrar_duplicados([1,2,3,2,1,4,5]))  # [1,2]

# ============================================================
# Ejercicio 26: Máximo producto sublista
# Enunciado: Encontrar subarray con mayor producto posible.
# ============================================================

def producto_maximo_sublista(a):
    if not a: return 0
    max_prod = min_prod = res = a[0]  # Inicializamos con primer elemento
    for x in a[1:]:
        if x < 0: max_prod, min_prod = min_prod, max_prod  # Intercambio si es negativo
        max_prod = max(x, max_prod * x)  # Calculamos máximo actual
        min_prod = min(x, min_prod * x)  # Calculamos mínimo actual
        res = max(res, max_prod)  # Actualizamos resultado
    return res

print(producto_maximo_sublista([2,3,-2,4]))  # 6

# ============================================================
# Ejercicio 27: Fila del triángulo de Pascal
# Enunciado: Generar la fila n del triángulo de Pascal.
# ============================================================

def fila_triangulo_pascal(n):
    if n==0: return [1]
    fila=[1]  # Iniciamos
    for i in range(1,n+1):
        fila=[1] + [fila[j-1]+fila[j] for j in range(1,len(fila))] + [1]  # Nueva fila
    return fila

print(fila_triangulo_pascal(4))  # [1,4,6,4,1]

#============================================================
# Ejercicio 28: Combinar k listas ordenadas
# Enunciado: Combinar varias listas ordenadas en una sola lista ordenada.
# ============================================================

import heapq

def combinar_listas_ordenadas(listas):
    heap=[]; res=[]
    for i, L in enumerate(listas):
        if L: heapq.heappush(heap,(L[0],i,0))  # Insertamos primer elemento de cada lista
    while heap:  # Mientras queden elementos
        val, li, idx = heapq.heappop(heap)  # Sacamos menor
        res.append(val)
        if idx+1 < len(listas[li]):  # Si la lista aún tiene más
            heapq.heappush(heap,(listas[li][idx+1],li,idx+1))
    return res

print(combinar_listas_ordenadas([[1,4,5],[1,3,4],[2,6]]))  # [1,1,2,3,4,4,5,6]

# ============================================================
# Ejercicio 29: Subconjuntos (power set)
# Enunciado: Generar todos los subconjuntos posibles de una lista.
# ============================================================

def generar_subconjuntos(lista):
    res=[[]]  # Iniciamos con conjunto vacío
    for e in lista:
        res += [s+[e] for s in res]  # Para cada subconjunto, añadimos el nuevo elemento
    return res

print(generar_subconjuntos([1,2,3]))  # [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

# ============================================================
# Ejercicio 30: Mayor rectángulo en histograma
# Enunciado: Encontrar el área del rectángulo más grande en un histograma.
# ============================================================

def mayor_rectangulo_histograma(alturas):
    pila=[]; max_area=0; i=0
    while i < len(alturas):
        if not pila or alturas[i] >= alturas[pila[-1]]:
            pila.append(i); i+=1  # Apilamos índice
        else:
            top = pila.pop()  # Sacamos último
            ancho = i if not pila else i - pila[-1] - 1  # Calculamos ancho
            max_area = max(max_area, alturas[top]*ancho)  # Área
    while pila:
        top = pila.pop()
        ancho = len(alturas) if not pila else len(alturas)-pila[-1]-1
        max_area = max(max_area, alturas[top]*ancho)
    return max_area

print(mayor_rectangulo_histograma([2,1,5,6,2,3]))  # 10

# ============================================================
# Ejercicio 31: Invertir lista enlazada simple
# Enunciado: Invertir el orden de los nodos en una lista enlazada simple.
# ============================================================

class Nodo:
    def __init__(self,val):  # Constructor de un nodo
        self.val=val  # Valor del nodo
        self.next=None  # Puntero al siguiente nodo

class ListaEnlazada:
    def __init__(self):
        self.head=None  # Inicio de la lista
    def agregar(self,val):
        n=Nodo(val)  # Creamos nodo
        if not self.head:  # Si la lista está vacía
            self.head=n
            return
        cur=self.head
        while cur.next:  # Avanzamos hasta el final
            cur=cur.next
        cur.next=n  # Agregamos al final
    def invertir(self):
        prev=None; cur=self.head
        while cur:  # Recorremos lista
            nxt=cur.next  # Guardamos siguiente
            cur.next=prev  # Invertimos enlace
            prev=cur; cur=nxt  # Avanzamos
        self.head=prev  # Nuevo inicio
    def to_list(self):
        r=[]; cur=self.head
        while cur:  # Recorremos
            r.append(cur.val)
            cur=cur.next
        return r

L=ListaEnlazada()
for i in range(1,6): L.agregar(i)
L.invertir()
print(L.to_list())  # [5,4,3,2,1]

# ============================================================
# Ejercicio 32: Detectar ciclo en lista enlazada (Floyd)
# Enunciado: Verificar si una lista enlazada contiene un ciclo.
# ============================================================

def tiene_ciclo(lista):
    if not lista.head: return False
    slow = fast = lista.head  # Dos punteros
    while fast and fast.next:
        slow = slow.next  # Avanza de uno en uno
        fast = fast.next.next  # Avanza de dos en dos
        if slow == fast: return True  # Se encontraron → hay ciclo
    return False

# Creamos lista con ciclo manualmente
a=Nodo(1); b=Nodo(2); c=Nodo(3)
a.next=b; b.next=c; c.next=a  # Ciclo aquí
tmp=type("T",(object,),{"head":a})()
print(tiene_ciclo(tmp))  # True

# ============================================================
# Ejercicio 33: Intersección de dos listas enlazadas
# Enunciado: Encontrar el nodo donde dos listas enlazadas se cruzan.
# ============================================================

def encontrar_interseccion(l1,l2):
    def len_list(l):
        cur=l.head; cnt=0
        while cur: cnt+=1; cur=cur.next
        return cnt
    if not l1.head or not l2.head: return None
    n1=len_list(l1); n2=len_list(l2)
    a,b = l1.head, l2.head
    if n1 > n2:
        for _ in range(n1-n2): a=a.next  # Avanzamos lista más larga
    else:
        for _ in range(n2-n1): b=b.next
    while a and b:
        if a == b: return a  # Intersección encontrada
        a=a.next; b=b.next
    return None

print("Intersección probada (ejemplo manual)")  # Aquí solo estructura

# ============================================================
# Ejercicio 34: Eliminar duplicados en lista enlazada ordenada
# Enunciado: Dada una lista enlazada ordenada, eliminar nodos repetidos.
# ============================================================

def eliminar_duplicados_ordenada(lista):
    cur=lista.head
    while cur and cur.next:
        if cur.val==cur.next.val:  # Si está repetido
            cur.next=cur.next.next  # Saltamos nodo duplicado
        else:
            cur=cur.next

L=ListaEnlazada()
for v in [1,1,2,3,3,4]: L.agregar(v)
eliminar_duplicados_ordenada(L)
print(L.to_list())  # [1,2,3,4]

# ============================================================
# Ejercicio 35: N-ésimo nodo desde el final
# Enunciado: Obtener el valor del nodo que está en la posición n desde el final.
# ============================================================

def nesimo_desde_final(lista,n):
    if not lista.head or n<=0: return None
    first=lista.head
    for _ in range(n):
        if not first: return None
        first=first.next
    second=lista.head
    while first:
        first=first.next; second=second.next
    return second.val

L=ListaEnlazada()
for i in range(1,6): L.agregar(i)
print(nesimo_desde_final(L,2))  # 4

# ============================================================
# Ejercicio 36: Sumar números representados como listas
# Enunciado: Dos listas enlazadas representan números, sumar resultado.
# ============================================================

def sumar_listas_numeros(l1,l2):
    s1=[]; s2=[]
    cur=l1.head
    while cur: s1.append(cur.val); cur=cur.next
    cur=l2.head
    while cur: s2.append(cur.val); cur=cur.next
    n1=int(''.join(map(str,s1))) if s1 else 0
    n2=int(''.join(map(str,s2))) if s2 else 0
    suma=list(map(int,str(n1+n2)))
    res=ListaEnlazada()
    for d in suma: res.agregar(d)
    return res

a=ListaEnlazada(); [a.agregar(d) for d in [2,4,3]]
b=ListaEnlazada(); [b.agregar(d) for d in [5,6,4]]
print(sumar_listas_numeros(a,b).to_list())  # [8,0,7]

# ============================================================
# Ejercicio 37: Palíndromo en lista enlazada
# Enunciado: Verificar si los valores en una lista enlazada forman un palíndromo.
# ============================================================

def es_palindromo(lista):
    slow=fast=lista.head
    stack=[]
    while fast and fast.next:
        stack.append(slow.val)  # Guardamos mitad
        slow=slow.next; fast=fast.next.next
    if fast: slow=slow.next  # Si es impar, saltamos centro
    while slow:
        if stack.pop()!=slow.val: return False
        slow=slow.next
    return True

L=ListaEnlazada()
for v in [1,2,3,2,1]: L.agregar(v)
print(es_palindromo(L))  # True

# ============================================================
# Ejercicio 38: Rotar lista enlazada
# Enunciado: Rotar una lista enlazada k posiciones a la derecha.
# ============================================================

def rotar_lista_enlazada(lista,k):
    if not lista.head or k==0: return
    tail=lista.head; n=1
    while tail.next: tail=tail.next; n+=1
    k%=n
    if k==0: return
    steps=n-k-1
    new_tail=lista.head
    for _ in range(steps): new_tail=new_tail.next
    new_head=new_tail.next
    new_tail.next=None
    tail.next=lista.head
    lista.head=new_head

L=ListaEnlazada(); [L.agregar(i) for i in range(1,6)]
rotar_lista_enlazada(L,2)
print(L.to_list())  # [4,5,1,2,3]

# ============================================================
# Ejercicio 39: Eliminar nodos alternativos
# Enunciado: Eliminar cada segundo nodo de una lista enlazada.
# ============================================================

def eliminar_nodos_alternativos(lista):
    cur=lista.head
    while cur and cur.next:
        cur.next=cur.next.next  # Saltamos un nodo
        cur=cur.next

L=ListaEnlazada(); [L.agregar(i) for i in range(1,7)]
eliminar_nodos_alternativos(L)
print(L.to_list())  # [1,3,5]

# ============================================================
# Ejercicio 40: Punto de unión en Y
# Enunciado: Encontrar el punto de unión entre dos listas en forma de Y.
# ============================================================

def encontrar_punto_union(l1,l2):
    return encontrar_interseccion(l1,l2)  # Reutilizamos función anterior

print("Función lista: se usaría con listas que comparten nodos")

# ============================================================
# Ejercicio 41: LRU Cache
# Enunciado: Implementar una caché con política "Least Recently Used".
# ============================================================

from collections import OrderedDict

class LRUCache:
    def __init__(self,capacidad):
        self.cap=capacidad  # Capacidad máxima
        self.cache=OrderedDict()  # Diccionario ordenado
    def get(self,key):
        if key not in self.cache: return -1  # No encontrado
        self.cache.move_to_end(key)  # Movemos al final como más reciente
        return self.cache[key]  # Retornamos valor
    def put(self,key,val):
        if key in self.cache:
            self.cache.move_to_end(key)  # Ya existe, actualizamos
        self.cache[key]=val
        if len(self.cache)>self.cap:
            self.cache.popitem(last=False)  # Eliminamos el menos usado

lru=LRUCache(2)
lru.put(1,1); lru.put(2,2)
print(lru.get(1))  # 1
lru.put(3,3)       # Saca la clave 2
print(lru.get(2))  # -1

# ============================================================
# Ejercicio 42: Evaluar polinomio con lista enlazada
# Enunciado: Cada nodo contiene coeficiente y exponente, evaluar para x.
# ============================================================

class NodoPoli:
    def __init__(self,coef,exp):
        self.coef=coef; self.exp=exp; self.next=None

def evaluar_polinomio(poli,x):
    res=0; cur=poli
    while cur:
        res+=cur.coef*(x**cur.exp)  # coef * x^exp
        cur=cur.next
    return res

# 3x^2 + 2x + 1
p=NodoPoli(3,2); p.next=NodoPoli(2,1); p.next.next=NodoPoli(1,0)
print(evaluar_polinomio(p,2))  # 17

# ============================================================
# Ejercicio 43: Sumar polinomios
# Enunciado: Sumar dos polinomios representados como listas enlazadas.
# ============================================================

def sumar_polinomios(p1,p2):
    dummy=NodoPoli(0,0); tail=dummy
    while p1 and p2:
        if p1.exp==p2.exp:
            tail.next=NodoPoli(p1.coef+p2.coef,p1.exp)
            p1=p1.next; p2=p2.next
        elif p1.exp>p2.exp:
            tail.next=NodoPoli(p1.coef,p1.exp); p1=p1.next
        else:
            tail.next=NodoPoli(p2.coef,p2.exp); p2=p2.next
        tail=tail.next
    tail.next=p1 if p1 else p2
    return dummy.next

# (3x^2+2x) + (x^2+4)
a=NodoPoli(3,2); a.next=NodoPoli(2,1)
b=NodoPoli(1,2); b.next=NodoPoli(4,0)
s=sumar_polinomios(a,b)
print(evaluar_polinomio(s,2))  # 22

# ============================================================
# Ejercicio 44: Árbol binario de búsqueda (insertar y recorrer)
# ============================================================

class NodoArbol:
    def __init__(self,val):
        self.val=val; self.izq=None; self.der=None

class ABB:
    def __init__(self):
        self.raiz=None
    def insertar(self,val):
        def _ins(nodo,val):
            if not nodo: return NodoArbol(val)
            if val<nodo.val: nodo.izq=_ins(nodo.izq,val)
            else: nodo.der=_ins(nodo.der,val)
            return nodo
        self.raiz=_ins(self.raiz,val)
    def inorder(self,nodo):
        return self.inorder(nodo.izq)+[nodo.val]+self.inorder(nodo.der) if nodo else []

abb=ABB()
for v in [5,3,7,2,4,6,8]: abb.insertar(v)
print(abb.inorder(abb.raiz))  # [2,3,4,5,6,7,8]

# ============================================================
# Ejercicio 45: Altura de un árbol binario
# ============================================================

def altura_arbol(nodo):
    if not nodo: return 0
    return 1+max(altura_arbol(nodo.izq),altura_arbol(nodo.der))

print(altura_arbol(abb.raiz))  # 3

# ============================================================
# Ejercicio 46: Recorridos BFS y DFS
# ============================================================

from collections import deque

def bfs(nodo):
    if not nodo: return []
    res=[]; q=deque([nodo])
    while q:
        cur=q.popleft(); res.append(cur.val)
        if cur.izq: q.append(cur.izq)
        if cur.der: q.append(cur.der)
    return res

def dfs(nodo):
    if not nodo: return []
    return [nodo.val]+dfs(nodo.izq)+dfs(nodo.der)

print(bfs(abb.raiz))  # [5,3,7,2,4,6,8]
print(dfs(abb.raiz))  # [5,3,2,4,7,6,8]

# ============================================================
# Ejercicio 47: Verificar árbol balanceado
# ============================================================

def es_balanceado(nodo):
    def altura(n):
        if not n: return 0
        iz=altura(n.izq); der=altura(n.der)
        if abs(iz-der)>1: raise ValueError  # Desbalance
        return 1+max(iz,der)
    try:
        altura(nodo)
        return True
    except:
        return False

print(es_balanceado(abb.raiz))  # True

# ============================================================
# Ejercicio 48: Camino más largo en árbol (diámetro)
# ============================================================

def diametro(nodo):
    max_d=[0]
    def dfs(n):
        if not n: return 0
        iz=dfs(n.izq); der=dfs(n.der)
        max_d[0]=max(max_d[0],iz+der)
        return 1+max(iz,der)
    dfs(nodo)
    return max_d[0]

print(diametro(abb.raiz))  # 4

# ============================================================
# Ejercicio 49: Heap (montículo mínimo)
# ============================================================

import heapq

class MinHeap:
    def __init__(self):
        self.data=[]
    def push(self,v):
        heapq.heappush(self.data,v)  # Insertar
    def pop(self):
        return heapq.heappop(self.data) if self.data else None

h=MinHeap()
for v in [5,3,8,1]: h.push(v)
print(h.pop())  # 1

# ============================================================
# Ejercicio 50: Ordenamiento topológico (Kahn)
# Enunciado: Dado un grafo dirigido acíclico, devolver orden topológico.
# ============================================================

from collections import defaultdict

def orden_topologico(grafo):
    indeg=defaultdict(int)
    for u in grafo:
        for v in grafo[u]:
            indeg[v]+=1
    q=deque([u for u in grafo if indeg[u]==0])
    res=[]
    while q:
        u=q.popleft(); res.append(u)
        for v in grafo[u]:
            indeg[v]-=1
            if indeg[v]==0: q.append(v)
    return res

g={"A":["C"],"B":["C","D"],"C":["E"],"D":["F"],"E":["H","F"],"F":["G"],"G":[],"H":[]}
print(orden_topologico(g))  # Un orden válido: ['A','B','C','D','E','H','F','G']